2010-07-08  Sandra Loosemore  <sandra@codesourcery.com>

	Backport from upstream (originally from Sourcery G++ 4.4):

	2010-07-02  Sandra Loosemore  <sandra@codesourcery.com>

	gcc/
	* config/arm/neon.md (vec_extractv2di): Correct error in register
	numbering to reconcile with neon_vget_lanev2di.

	2010-07-02  Sandra Loosemore  <sandra@codesourcery.com>

	gcc/
	* config/arm/arm.c (neon_vdup_constant): Expand into canonical RTL
	instead of an unspec.
	(neon_expand_vector_init): Likewise.
	* config/arm/neon.md (UNSPEC_VCOMBINE): Delete.
	(UNSPEC_VDUP_LANE): Delete.
	(UNSPEC VDUP_N): Delete.
	(UNSPEC_VGET_HIGH): Delete.
	(UNSPEC_VGET_LANE): Delete.
	(UNSPEC_VGET_LOW): Delete.
	(UNSPEC_VMVN): Delete.
	(UNSPEC_VSET_LANE): Delete.
	(V_double_vector_mode): New.
	(vec_set<mode>_internal): Make code emitted match that for the
	corresponding intrinsics.
	(vec_setv2di_internal): Likewise.
	(neon_vget_lanedi): Rewrite to expand into emit_move_insn.
	(neon_vget_lanev2di): Rewrite to expand into vec_extractv2di.
	(neon_vset_lane<mode>): Combine double and quad patterns and
	expand into vec_set<mode>_internal instead of UNSPEC_VSET_LANE.
	(neon_vset_lanedi): Rewrite to expand into emit_move_insn.
	(neon_vdup_n<mode>): Rewrite RTL without unspec.
	(neon_vdup_ndi): Rewrite as define_expand and use emit_move_insn.
	(neon_vdup_nv2di): Rewrite RTL without unspec and merge with
	with neon_vdup_lanev2di, adjusting the pattern from the latter
	to be predicable for consistency.
	(neon_vdup_lane<mode>_internal): New.
	(neon_vdup_lane<mode>): Turn into a define_expand and rewrite
	to avoid using an unspec.
	(neon_vdup_lanedi): Rewrite RTL pattern to avoid unspec.
	(neon_vdup_lanev2di): Turn into a define_expand.
	(neon_vcombine): Rewrite pattern to eliminate UNPSEC_VCOMBINE.
	(neon_vget_high<mode>): Replace with....
	(neon_vget_highv16qi): New pattern using canonical RTL.
	(neon_vget_highv8hi): Likewise.
	(neon_vget_highv4si): Likewise.
	(neon_vget_highv4sf): Likewise.
	(neon_vget_highv2di): Likewise.
	(neon_vget_low<mode>): Replace with....
	(neon_vget_lowv16qi): New pattern using canonical RTL.
	(neon_vget_lowv8hi): Likewise.
	(neon_vget_lowv4si): Likewise.
	(neon_vget_lowv4sf): Likewise.
	(neon_vget_lowv2di): Likewise.

	* config/arm/neon.ml (Vget_lane): Add No_op attribute to suppress
	test for this emitting vmov.
	(Vset_lane): Likewise.
	(Vdup_n): Likewise.
	(Vmov_n): Likewise.

	* doc/arm-neon-intrinsics.texi: Regenerated.

	gcc/testsuite/
	* gcc.target/arm/neon/vdup_ns64.c: Regenerated.
	* gcc.target/arm/neon/vdup_nu64.c: Regenerated.
	* gcc.target/arm/neon/vdupQ_ns64.c: Regenerated.
	* gcc.target/arm/neon/vdupQ_nu64.c: Regenerated.
	* gcc.target/arm/neon/vmov_ns64.c: Regenerated.
	* gcc.target/arm/neon/vmov_nu64.c: Regenerated.
	* gcc.target/arm/neon/vmovQ_ns64.c: Regenerated.
	* gcc.target/arm/neon/vmovQ_nu64.c: Regenerated.
	* gcc.target/arm/neon/vget_lanes64.c: Regenerated.
	* gcc.target/arm/neon/vget_laneu64.c: Regenerated.
	* gcc.target/arm/neon/vset_lanes64.c: Regenerated.
	* gcc.target/arm/neon/vset_laneu64.c: Regenerated.
	* gcc.target/arm/neon-vdup_ns64.c: New.
	* gcc.target/arm/neon-vdup_nu64.c: New.
	* gcc.target/arm/neon-vdupQ_ns64.c: New.
	* gcc.target/arm/neon-vdupQ_nu64.c: New.
	* gcc.target/arm/neon-vdupQ_lanes64.c: New.
	* gcc.target/arm/neon-vdupQ_laneu64.c: New.
	* gcc.target/arm/neon-vmov_ns64.c: New.
	* gcc.target/arm/neon-vmov_nu64.c: New.
	* gcc.target/arm/neon-vmovQ_ns64.c: New.
	* gcc.target/arm/neon-vmovQ_nu64.c: New.
	* gcc.target/arm/neon-vget_lanes64.c: New.
	* gcc.target/arm/neon-vget_laneu64.c: New.
	* gcc.target/arm/neon-vset_lanes64.c: New.
	* gcc.target/arm/neon-vset_laneu64.c: New.

	2010-07-02  Sandra Loosemore  <sandra@codesourcery.com>
		    Julian Brown  <julian@codesourcery.com>

	gcc/
	* config/arm/neon.md (UNSPEC_VABA): Delete.
	(UNSPEC_VABAL): Delete.
	(UNSPEC_VABS): Delete.
	(UNSPEC_VMUL_N): Delete.
	(adddi3_neon): New.
	(subdi3_neon): New.
	(mul<mode>3add<mode>_neon): Make the pattern named.
	(mul<mode>3neg<mode>add<mode>_neon): Likewise.
	(neon_vadd<mode>): Replace with define_expand, and move the remaining
	unspec parts...
	(neon_vadd<mode>_unspec): ...to this.
	(neon_vmla<mode>, neon_vmla<mode>_unspec): Likewise.
	(neon_vlms<mode>, neon_vmls<mode>_unspec): Likewise.
	(neon_vsub<mode>, neon_vsub<mode>_unspec): Likewise.
	(neon_vaba<mode>): Rewrite in terms of vabd.
	(neon_vabal<mode>): Rewrite in terms of vabdl.
	(neon_vabs<mode>): Rewrite without unspec.
	* config/arm/arm.md (*arm_adddi3): Disable for TARGET_NEON.
	(*arm_subdi3): Likewise.
	* config/arm/neon.ml (Vadd, Vsub): Split out 64-bit variants and add
	No_op attribute to disable assembly output checks.
	* config/arm/arm_neon.h: Regenerated.
	* doc/arm-neon-intrinsics.texi: Regenerated.

	gcc/testsuite/
	* gcc.target/arm/neon/vadds64.c: Regenerated.
	* gcc.target/arm/neon/vaddu64.c: Regenerated.
	* gcc.target/arm/neon/vsubs64.c: Regenerated.
	* gcc.target/arm/neon/vsubu64.c: Regenerated.
	* gcc.target/arm/neon-vmla-1.c: Add -ffast-math to options.
	* gcc.target/arm/neon-vmls-1.c: Likewise.
	* gcc.target/arm/neon-vsubs64.c: New execution test.
	* gcc.target/arm/neon-vsubu64.c: New execution test.
	* gcc.target/arm/neon-vadds64.c: New execution test.
	* gcc.target/arm/neon-vaddu64.c: New execution test.

=== modified file 'gcc/config/arm/arm.c'
--- old/gcc/config/arm/arm.c	2010-07-29 15:53:39 +0000
+++ new/gcc/config/arm/arm.c	2010-07-29 15:59:12 +0000
@@ -8110,8 +8110,7 @@
      load.  */
 
   x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));
-  return gen_rtx_UNSPEC (mode, gen_rtvec (1, x),
-			 UNSPEC_VDUP_N);
+  return gen_rtx_VEC_DUPLICATE (mode, x);
 }
 
 /* Generate code to load VALS, which is a PARALLEL containing only
@@ -8207,8 +8206,7 @@
     {
       x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));
       emit_insn (gen_rtx_SET (VOIDmode, target,
-			      gen_rtx_UNSPEC (mode, gen_rtvec (1, x),
-					      UNSPEC_VDUP_N)));
+			      gen_rtx_VEC_DUPLICATE (mode, x)));
       return;
     }
 
@@ -8217,7 +8215,7 @@
   if (n_var == 1)
     {
       rtx copy = copy_rtx (vals);
-      rtvec ops;
+      rtx index = GEN_INT (one_var);
 
       /* Load constant part of vector, substitute neighboring value for
 	 varying element.  */
@@ -8226,9 +8224,38 @@
 
       /* Insert variable.  */
       x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, one_var));
-      ops = gen_rtvec (3, x, target, GEN_INT (one_var));
-      emit_insn (gen_rtx_SET (VOIDmode, target,
-			      gen_rtx_UNSPEC (mode, ops, UNSPEC_VSET_LANE)));
+      switch (mode)
+	{
+	case V8QImode:
+	  emit_insn (gen_neon_vset_lanev8qi (target, x, target, index));
+	  break;
+	case V16QImode:
+	  emit_insn (gen_neon_vset_lanev16qi (target, x, target, index));
+	  break;
+	case V4HImode:
+	  emit_insn (gen_neon_vset_lanev4hi (target, x, target, index));
+	  break;
+	case V8HImode:
+	  emit_insn (gen_neon_vset_lanev8hi (target, x, target, index));
+	  break;
+	case V2SImode:
+	  emit_insn (gen_neon_vset_lanev2si (target, x, target, index));
+	  break;
+	case V4SImode:
+	  emit_insn (gen_neon_vset_lanev4si (target, x, target, index));
+	  break;
+	case V2SFmode:
+	  emit_insn (gen_neon_vset_lanev2sf (target, x, target, index));
+	  break;
+	case V4SFmode:
+	  emit_insn (gen_neon_vset_lanev4sf (target, x, target, index));
+	  break;
+	case V2DImode:
+	  emit_insn (gen_neon_vset_lanev2di (target, x, target, index));
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
       return;
     }
 

=== modified file 'gcc/config/arm/arm.md'
--- old/gcc/config/arm/arm.md	2010-04-02 18:54:46 +0000
+++ new/gcc/config/arm/arm.md	2010-07-29 15:59:12 +0000
@@ -497,9 +497,10 @@
 	(plus:DI (match_operand:DI 1 "s_register_operand" "%0, 0")
 		 (match_operand:DI 2 "s_register_operand" "r,  0")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)"
+  "TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_MAVERICK) && !TARGET_NEON"
   "#"
-  "TARGET_32BIT && reload_completed"
+  "TARGET_32BIT && reload_completed
+   && ! (TARGET_NEON && IS_VFP_REGNUM (REGNO (operands[0])))"
   [(parallel [(set (reg:CC_C CC_REGNUM)
 		   (compare:CC_C (plus:SI (match_dup 1) (match_dup 2))
 				 (match_dup 1)))
@@ -997,7 +998,7 @@
 	(minus:DI (match_operand:DI 1 "s_register_operand" "0,r,0")
 		  (match_operand:DI 2 "s_register_operand" "r,0,0")))
    (clobber (reg:CC CC_REGNUM))]
-  "TARGET_32BIT"
+  "TARGET_32BIT && !TARGET_NEON"
   "subs\\t%Q0, %Q1, %Q2\;sbc\\t%R0, %R1, %R2"
   [(set_attr "conds" "clob")
    (set_attr "length" "8")]
@@ -1784,6 +1785,7 @@
 	  [(match_operand:DI 1 "s_register_operand" "")
 	   (match_operand:DI 2 "s_register_operand" "")]))]
   "TARGET_32BIT && reload_completed
+   && ! (TARGET_NEON && IS_VFP_REGNUM (REGNO (operands[0])))
    && ! IS_IWMMXT_REGNUM (REGNO (operands[0]))"
   [(set (match_dup 0) (match_op_dup:SI 6 [(match_dup 1) (match_dup 2)]))
    (set (match_dup 3) (match_op_dup:SI 6 [(match_dup 4) (match_dup 5)]))]
@@ -1857,11 +1859,19 @@
   }"
 )
 
-(define_insn "anddi3"
+(define_expand "anddi3"
+  [(set (match_operand:DI         0 "s_register_operand" "")
+	(and:DI (match_operand:DI 1 "s_register_operand" "")
+		(match_operand:DI 2 "neon_inv_logic_op2" "")))]
+  "TARGET_32BIT"
+  ""
+)
+
+(define_insn "*anddi3_insn"
   [(set (match_operand:DI         0 "s_register_operand" "=&r,&r")
 	(and:DI (match_operand:DI 1 "s_register_operand"  "%0,r")
 		(match_operand:DI 2 "s_register_operand"   "r,r")))]
-  "TARGET_32BIT && ! TARGET_IWMMXT"
+  "TARGET_32BIT && !TARGET_IWMMXT && !TARGET_NEON"
   "#"
   [(set_attr "length" "8")]
 )
@@ -2461,7 +2471,9 @@
 		(match_operand:DI 2 "s_register_operand" "r,0")))]
   "TARGET_32BIT"
   "#"
-  "TARGET_32BIT && reload_completed && ! IS_IWMMXT_REGNUM (REGNO (operands[0]))"
+  "TARGET_32BIT && reload_completed
+   && ! (TARGET_NEON && IS_VFP_REGNUM (REGNO (operands[0])))
+   && ! IS_IWMMXT_REGNUM (REGNO (operands[0]))"
   [(set (match_dup 0) (and:SI (not:SI (match_dup 1)) (match_dup 2)))
    (set (match_dup 3) (and:SI (not:SI (match_dup 4)) (match_dup 5)))]
   "
@@ -2585,11 +2597,19 @@
   [(set_attr "conds" "set")]
 )
 
-(define_insn "iordi3"
+(define_expand "iordi3"
+  [(set (match_operand:DI         0 "s_register_operand" "")
+	(ior:DI (match_operand:DI 1 "s_register_operand" "")
+		(match_operand:DI 2 "neon_logic_op2" "")))]
+  "TARGET_32BIT"
+  ""
+)
+
+(define_insn "*iordi3_insn"
   [(set (match_operand:DI         0 "s_register_operand" "=&r,&r")
 	(ior:DI (match_operand:DI 1 "s_register_operand"  "%0,r")
 		(match_operand:DI 2 "s_register_operand"   "r,r")))]
-  "TARGET_32BIT && ! TARGET_IWMMXT"
+  "TARGET_32BIT && !TARGET_IWMMXT && !TARGET_NEON"
   "#"
   [(set_attr "length" "8")
    (set_attr "predicable" "yes")]
@@ -2715,11 +2735,19 @@
   [(set_attr "conds" "set")]
 )
 
-(define_insn "xordi3"
+(define_expand "xordi3"
+  [(set (match_operand:DI         0 "s_register_operand" "")
+	(xor:DI (match_operand:DI 1 "s_register_operand" "")
+		(match_operand:DI 2 "s_register_operand" "")))]
+  "TARGET_32BIT"
+  ""
+)
+
+(define_insn "*xordi3_insn"
   [(set (match_operand:DI         0 "s_register_operand" "=&r,&r")
 	(xor:DI (match_operand:DI 1 "s_register_operand"  "%0,r")
 		(match_operand:DI 2 "s_register_operand"   "r,r")))]
-  "TARGET_32BIT && !TARGET_IWMMXT"
+  "TARGET_32BIT && !TARGET_IWMMXT && !TARGET_NEON"
   "#"
   [(set_attr "length" "8")
    (set_attr "predicable" "yes")]

=== modified file 'gcc/config/arm/arm_neon.h'
--- old/gcc/config/arm/arm_neon.h	2009-11-03 17:58:59 +0000
+++ new/gcc/config/arm/arm_neon.h	2010-07-29 15:59:12 +0000
@@ -414,12 +414,6 @@
   return (int32x2_t)__builtin_neon_vaddv2si (__a, __b, 1);
 }
 
-__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vadd_s64 (int64x1_t __a, int64x1_t __b)
-{
-  return (int64x1_t)__builtin_neon_vadddi (__a, __b, 1);
-}
-
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vadd_f32 (float32x2_t __a, float32x2_t __b)
 {
@@ -444,6 +438,12 @@
   return (uint32x2_t)__builtin_neon_vaddv2si ((int32x2_t) __a, (int32x2_t) __b, 0);
 }
 
+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
+vadd_s64 (int64x1_t __a, int64x1_t __b)
+{
+  return (int64x1_t)__builtin_neon_vadddi (__a, __b, 1);
+}
+
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vadd_u64 (uint64x1_t __a, uint64x1_t __b)
 {
@@ -1368,12 +1368,6 @@
   return (int32x2_t)__builtin_neon_vsubv2si (__a, __b, 1);
 }
 
-__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vsub_s64 (int64x1_t __a, int64x1_t __b)
-{
-  return (int64x1_t)__builtin_neon_vsubdi (__a, __b, 1);
-}
-
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vsub_f32 (float32x2_t __a, float32x2_t __b)
 {
@@ -1398,6 +1392,12 @@
   return (uint32x2_t)__builtin_neon_vsubv2si ((int32x2_t) __a, (int32x2_t) __b, 0);
 }
 
+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
+vsub_s64 (int64x1_t __a, int64x1_t __b)
+{
+  return (int64x1_t)__builtin_neon_vsubdi (__a, __b, 1);
+}
+
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vsub_u64 (uint64x1_t __a, uint64x1_t __b)
 {
@@ -5808,12 +5808,6 @@
   return (int32x2_t)__builtin_neon_vget_lowv4si (__a);
 }
 
-__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vget_low_s64 (int64x2_t __a)
-{
-  return (int64x1_t)__builtin_neon_vget_lowv2di (__a);
-}
-
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vget_low_f32 (float32x4_t __a)
 {
@@ -5838,12 +5832,6 @@
   return (uint32x2_t)__builtin_neon_vget_lowv4si ((int32x4_t) __a);
 }
 
-__extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
-vget_low_u64 (uint64x2_t __a)
-{
-  return (uint64x1_t)__builtin_neon_vget_lowv2di ((int64x2_t) __a);
-}
-
 __extension__ static __inline poly8x8_t __attribute__ ((__always_inline__))
 vget_low_p8 (poly8x16_t __a)
 {
@@ -5856,6 +5844,18 @@
   return (poly16x4_t)__builtin_neon_vget_lowv8hi ((int16x8_t) __a);
 }
 
+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
+vget_low_s64 (int64x2_t __a)
+{
+  return (int64x1_t)__builtin_neon_vget_lowv2di (__a);
+}
+
+__extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
+vget_low_u64 (uint64x2_t __a)
+{
+  return (uint64x1_t)__builtin_neon_vget_lowv2di ((int64x2_t) __a);
+}
+
 __extension__ static __inline int32x2_t __attribute__ ((__always_inline__))
 vcvt_s32_f32 (float32x2_t __a)
 {
@@ -10386,12 +10386,6 @@
   return (int32x2_t)__builtin_neon_vandv2si (__a, __b, 1);
 }
 
-__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vand_s64 (int64x1_t __a, int64x1_t __b)
-{
-  return (int64x1_t)__builtin_neon_vanddi (__a, __b, 1);
-}
-
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
 vand_u8 (uint8x8_t __a, uint8x8_t __b)
 {
@@ -10410,6 +10404,12 @@
   return (uint32x2_t)__builtin_neon_vandv2si ((int32x2_t) __a, (int32x2_t) __b, 0);
 }
 
+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
+vand_s64 (int64x1_t __a, int64x1_t __b)
+{
+  return (int64x1_t)__builtin_neon_vanddi (__a, __b, 1);
+}
+
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vand_u64 (uint64x1_t __a, uint64x1_t __b)
 {
@@ -10482,12 +10482,6 @@
   return (int32x2_t)__builtin_neon_vorrv2si (__a, __b, 1);
 }
 
-__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vorr_s64 (int64x1_t __a, int64x1_t __b)
-{
-  return (int64x1_t)__builtin_neon_vorrdi (__a, __b, 1);
-}
-
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
 vorr_u8 (uint8x8_t __a, uint8x8_t __b)
 {
@@ -10506,6 +10500,12 @@
   return (uint32x2_t)__builtin_neon_vorrv2si ((int32x2_t) __a, (int32x2_t) __b, 0);
 }
 
+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
+vorr_s64 (int64x1_t __a, int64x1_t __b)
+{
+  return (int64x1_t)__builtin_neon_vorrdi (__a, __b, 1);
+}
+
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vorr_u64 (uint64x1_t __a, uint64x1_t __b)
 {
@@ -10578,12 +10578,6 @@
   return (int32x2_t)__builtin_neon_veorv2si (__a, __b, 1);
 }
 
-__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-veor_s64 (int64x1_t __a, int64x1_t __b)
-{
-  return (int64x1_t)__builtin_neon_veordi (__a, __b, 1);
-}
-
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
 veor_u8 (uint8x8_t __a, uint8x8_t __b)
 {
@@ -10602,6 +10596,12 @@
   return (uint32x2_t)__builtin_neon_veorv2si ((int32x2_t) __a, (int32x2_t) __b, 0);
 }
 
+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
+veor_s64 (int64x1_t __a, int64x1_t __b)
+{
+  return (int64x1_t)__builtin_neon_veordi (__a, __b, 1);
+}
+
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 veor_u64 (uint64x1_t __a, uint64x1_t __b)
 {
@@ -10674,12 +10674,6 @@
   return (int32x2_t)__builtin_neon_vbicv2si (__a, __b, 1);
 }
 
-__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vbic_s64 (int64x1_t __a, int64x1_t __b)
-{
-  return (int64x1_t)__builtin_neon_vbicdi (__a, __b, 1);
-}
-
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
 vbic_u8 (uint8x8_t __a, uint8x8_t __b)
 {
@@ -10698,6 +10692,12 @@
   return (uint32x2_t)__builtin_neon_vbicv2si ((int32x2_t) __a, (int32x2_t) __b, 0);
 }
 
+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
+vbic_s64 (int64x1_t __a, int64x1_t __b)
+{
+  return (int64x1_t)__builtin_neon_vbicdi (__a, __b, 1);
+}
+
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vbic_u64 (uint64x1_t __a, uint64x1_t __b)
 {
@@ -10770,12 +10770,6 @@
   return (int32x2_t)__builtin_neon_vornv2si (__a, __b, 1);
 }
 
-__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
-vorn_s64 (int64x1_t __a, int64x1_t __b)
-{
-  return (int64x1_t)__builtin_neon_vorndi (__a, __b, 1);
-}
-
 __extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
 vorn_u8 (uint8x8_t __a, uint8x8_t __b)
 {
@@ -10794,6 +10788,12 @@
   return (uint32x2_t)__builtin_neon_vornv2si ((int32x2_t) __a, (int32x2_t) __b, 0);
 }
 
+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
+vorn_s64 (int64x1_t __a, int64x1_t __b)
+{
+  return (int64x1_t)__builtin_neon_vorndi (__a, __b, 1);
+}
+
 __extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
 vorn_u64 (uint64x1_t __a, uint64x1_t __b)
 {

=== modified file 'gcc/config/arm/neon.md'
--- old/gcc/config/arm/neon.md	2009-11-11 14:23:03 +0000
+++ new/gcc/config/arm/neon.md	2010-07-29 15:59:12 +0000
@@ -22,17 +22,12 @@
 (define_constants
   [(UNSPEC_ASHIFT_SIGNED	65)
    (UNSPEC_ASHIFT_UNSIGNED	66)
-   (UNSPEC_VABA			67)
-   (UNSPEC_VABAL		68)
    (UNSPEC_VABD			69)
    (UNSPEC_VABDL		70)
-   (UNSPEC_VABS			71)
    (UNSPEC_VADD			72)
    (UNSPEC_VADDHN		73)
    (UNSPEC_VADDL		74)
    (UNSPEC_VADDW		75)
-   (UNSPEC_VAND			76)
-   (UNSPEC_VBIC			77)
    (UNSPEC_VBSL			78)
    (UNSPEC_VCAGE		79)
    (UNSPEC_VCAGT		80)
@@ -40,18 +35,9 @@
    (UNSPEC_VCGE			82)
    (UNSPEC_VCGT			83)
    (UNSPEC_VCLS			84)
-   (UNSPEC_VCLZ			85)
-   (UNSPEC_VCNT			86)
-   (UNSPEC_VCOMBINE		87)
    (UNSPEC_VCVT			88)
    (UNSPEC_VCVT_N		89)
-   (UNSPEC_VDUP_LANE		90)
-   (UNSPEC_VDUP_N		91)
-   (UNSPEC_VEOR			92)
    (UNSPEC_VEXT			93)
-   (UNSPEC_VGET_HIGH		94)
-   (UNSPEC_VGET_LANE		95)
-   (UNSPEC_VGET_LOW		96)
    (UNSPEC_VHADD		97)
    (UNSPEC_VHSUB		98)
    (UNSPEC_VLD1			99)
@@ -86,10 +72,6 @@
    (UNSPEC_VMULL		128)
    (UNSPEC_VMUL_LANE		129)
    (UNSPEC_VMULL_LANE		130)
-   (UNSPEC_VMUL_N		131)
-   (UNSPEC_VMVN			132)
-   (UNSPEC_VORN			133)
-   (UNSPEC_VORR			134)
    (UNSPEC_VPADAL		135)
    (UNSPEC_VPADD		136)
    (UNSPEC_VPADDL		137)
@@ -125,7 +107,6 @@
    (UNSPEC_VREV64		167)
    (UNSPEC_VRSQRTE		168)
    (UNSPEC_VRSQRTS		169)
-   (UNSPEC_VSET_LANE		170)
    (UNSPEC_VSHL			171)
    (UNSPEC_VSHLL_N		172)
    (UNSPEC_VSHL_N		173)
@@ -335,6 +316,14 @@
 				  (V4HI "V2SI") (V8HI "V4SI")
 				  (V2SI "DI")   (V4SI "V2DI")])
 
+;; Double-sized modes with the same element size.
+;; Used for neon_vdup_lane, where the second operand is double-sized
+;; even when the first one is quad.
+(define_mode_attr V_double_vector_mode [(V16QI "V8QI") (V8HI "V4HI")
+                                        (V4SI "V2SI") (V4SF "V2SF")
+                                        (V8QI "V8QI") (V4HI "V4HI")
+                                        (V2SI "V2SI") (V2SF "V2SF")])
+
 ;; Mode of result of comparison operations (and bit-select operand 1).
 (define_mode_attr V_cmp_result [(V8QI "V8QI") (V16QI "V16QI")
 			        (V4HI "V4HI") (V8HI  "V8HI")
@@ -688,7 +677,7 @@
     elt = GET_MODE_NUNITS (<MODE>mode) - 1 - elt;
   operands[2] = GEN_INT (elt);
   
-  return "vmov%?.<V_uf_sclr>\t%P0[%c2], %1";
+  return "vmov%?.<V_sz_elem>\t%P0[%c2], %1";
 }
   [(set_attr "predicable" "yes")
    (set_attr "neon_type" "neon_mcr")])
@@ -714,7 +703,7 @@
   operands[0] = gen_rtx_REG (<V_HALF>mode, regno + hi);
   operands[2] = GEN_INT (elt);
 
-  return "vmov%?.<V_uf_sclr>\t%P0[%c2], %1";
+  return "vmov%?.<V_sz_elem>\t%P0[%c2], %1";
 }
   [(set_attr "predicable" "yes")
    (set_attr "neon_type" "neon_mcr")]
@@ -734,7 +723,7 @@
 
   operands[0] = gen_rtx_REG (DImode, regno);
 
-  return "vmov%?.64\t%P0, %Q1, %R1";
+  return "vmov%?\t%P0, %Q1, %R1";
 }
   [(set_attr "predicable" "yes")
    (set_attr "neon_type" "neon_mcr_2_mcrr")]
@@ -802,11 +791,11 @@
           (parallel [(match_operand:SI 2 "immediate_operand" "i")])))]
   "TARGET_NEON"
 {
-  int regno = REGNO (operands[1]) + INTVAL (operands[2]);
+  int regno = REGNO (operands[1]) + 2 * INTVAL (operands[2]);
 
   operands[1] = gen_rtx_REG (DImode, regno);
 
-  return "vmov%?.64\t%Q0, %R0, %P1";
+  return "vmov%?\t%Q0, %R0, %P1  @ v2di";
 }
   [(set_attr "predicable" "yes")
    (set_attr "neon_type" "neon_int_1")]
@@ -823,11 +812,8 @@
 
 ;; Doubleword and quadword arithmetic.
 
-;; NOTE: vadd/vsub and some other instructions also support 64-bit integer
-;; element size, which we could potentially use for "long long" operations. We
-;; don't want to do this at present though, because moving values from the
-;; vector unit to the ARM core is currently slow and 64-bit addition (etc.) is
-;; easy to do with ARM instructions anyway.
+;; NOTE: some other instructions also support 64-bit integer
+;; element size, which we could potentially use for "long long" operations.
 
 (define_insn "*add<mode>3_neon"
   [(set (match_operand:VDQ 0 "s_register_operand" "=w")
@@ -843,6 +829,26 @@
                     (const_string "neon_int_1")))]
 )
 
+(define_insn "adddi3_neon"
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?&r,?&r")
+        (plus:DI (match_operand:DI 1 "s_register_operand" "%w,0,0")
+                 (match_operand:DI 2 "s_register_operand" "w,r,0")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_NEON"
+{
+  switch (which_alternative)
+    {
+    case 0: return "vadd.i64\t%P0, %P1, %P2";
+    case 1: return "#";
+    case 2: return "#";
+    default: gcc_unreachable ();
+    }
+}
+  [(set_attr "neon_type" "neon_int_1,*,*")
+   (set_attr "conds" "*,clob,clob")
+   (set_attr "length" "*,8,8")]
+)
+
 (define_insn "*sub<mode>3_neon"
   [(set (match_operand:VDQ 0 "s_register_operand" "=w")
         (minus:VDQ (match_operand:VDQ 1 "s_register_operand" "w")
@@ -857,6 +863,27 @@
                     (const_string "neon_int_2")))]
 )
 
+(define_insn "subdi3_neon"
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?&r,?&r,?&r")
+        (minus:DI (match_operand:DI 1 "s_register_operand" "w,0,r,0")
+                  (match_operand:DI 2 "s_register_operand" "w,r,0,0")))
+   (clobber (reg:CC CC_REGNUM))]
+  "TARGET_NEON"
+{
+  switch (which_alternative)
+    {
+    case 0: return "vsub.i64\t%P0, %P1, %P2";
+    case 1: /* fall through */ 
+    case 2: /* fall through */
+    case 3: return  "subs\\t%Q0, %Q1, %Q2\;sbc\\t%R0, %R1, %R2";
+    default: gcc_unreachable ();
+    }
+}
+  [(set_attr "neon_type" "neon_int_2,*,*,*")
+   (set_attr "conds" "*,clob,clob,clob")
+   (set_attr "length" "*,8,8,8")]
+)
+
 (define_insn "*mul<mode>3_neon"
   [(set (match_operand:VDQ 0 "s_register_operand" "=w")
         (mult:VDQ (match_operand:VDQ 1 "s_register_operand" "w")
@@ -878,7 +905,7 @@
                                     (const_string "neon_mul_qqq_8_16_32_ddd_32")))))]
 )
 
-(define_insn "*mul<mode>3add<mode>_neon"
+(define_insn "mul<mode>3add<mode>_neon"
   [(set (match_operand:VDQ 0 "s_register_operand" "=w")
         (plus:VDQ (mult:VDQ (match_operand:VDQ 2 "s_register_operand" "w")
                             (match_operand:VDQ 3 "s_register_operand" "w"))
@@ -900,7 +927,7 @@
                                     (const_string "neon_mla_qqq_32_qqd_32_scalar")))))]
 )
 
-(define_insn "*mul<mode>3neg<mode>add<mode>_neon"
+(define_insn "mul<mode>3neg<mode>add<mode>_neon"
   [(set (match_operand:VDQ 0 "s_register_operand" "=w")
         (minus:VDQ (match_operand:VDQ 1 "s_register_operand" "0")
                    (mult:VDQ (match_operand:VDQ 2 "s_register_operand" "w")
@@ -940,10 +967,9 @@
 )
 
 (define_insn "iordi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w,w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w,0")
-		    (match_operand:DI 2 "neon_logic_op2" "w,Dl")]
-                    UNSPEC_VORR))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,w,?&r,?&r")
+        (ior:DI (match_operand:DI 1 "s_register_operand" "%w,0,0,r")
+		(match_operand:DI 2 "neon_logic_op2" "w,Dl,r,r")))]
   "TARGET_NEON"
 {
   switch (which_alternative)
@@ -951,10 +977,13 @@
     case 0: return "vorr\t%P0, %P1, %P2";
     case 1: return neon_output_logic_immediate ("vorr", &operands[2],
 		     DImode, 0, VALID_NEON_QREG_MODE (DImode));
+    case 2: return "#";
+    case 3: return "#";
     default: gcc_unreachable ();
     }
 }
-  [(set_attr "neon_type" "neon_int_1")]
+  [(set_attr "neon_type" "neon_int_1,neon_int_1,*,*")
+   (set_attr "length" "*,*,8,8")]
 )
 
 ;; The concrete forms of the Neon immediate-logic instructions are vbic and
@@ -980,10 +1009,9 @@
 )
 
 (define_insn "anddi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w,w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w,0")
-		    (match_operand:DI 2 "neon_inv_logic_op2" "w,DL")]
-                    UNSPEC_VAND))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,w,?&r,?&r")
+        (and:DI (match_operand:DI 1 "s_register_operand" "%w,0,0,r")
+		(match_operand:DI 2 "neon_inv_logic_op2" "w,DL,r,r")))]
   "TARGET_NEON"
 {
   switch (which_alternative)
@@ -991,10 +1019,13 @@
     case 0: return "vand\t%P0, %P1, %P2";
     case 1: return neon_output_logic_immediate ("vand", &operands[2],
     		     DImode, 1, VALID_NEON_QREG_MODE (DImode));
+    case 2: return "#";
+    case 3: return "#";
     default: gcc_unreachable ();
     }
 }
-  [(set_attr "neon_type" "neon_int_1")]
+  [(set_attr "neon_type" "neon_int_1,neon_int_1,*,*")
+   (set_attr "length" "*,*,8,8")]
 )
 
 (define_insn "orn<mode>3_neon"
@@ -1007,13 +1038,16 @@
 )
 
 (define_insn "orndi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w")
-		    (match_operand:DI 2 "s_register_operand" "w")]
-                    UNSPEC_VORN))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?=&r,?&r")
+	(ior:DI (match_operand:DI 1 "s_register_operand" "w,r,0")
+	         (not:DI (match_operand:DI 2 "s_register_operand" "w,0,r"))))]
   "TARGET_NEON"
-  "vorn\t%P0, %P1, %P2"
-  [(set_attr "neon_type" "neon_int_1")]
+  "@
+   vorn\t%P0, %P1, %P2
+   #
+   #"
+  [(set_attr "neon_type" "neon_int_1,*,*")
+   (set_attr "length" "*,8,8")]
 )
 
 (define_insn "bic<mode>3_neon"
@@ -1025,14 +1059,18 @@
   [(set_attr "neon_type" "neon_int_1")]
 )
 
+;; Compare to *anddi_notdi_di.
 (define_insn "bicdi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w")
-		     (match_operand:DI 2 "s_register_operand" "w")]
-                    UNSPEC_VBIC))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?=&r,?&r")
+        (and:DI (not:DI (match_operand:DI 2 "s_register_operand" "w,r,0"))
+		(match_operand:DI 1 "s_register_operand" "w,0,r")))]
   "TARGET_NEON"
-  "vbic\t%P0, %P1, %P2"
-  [(set_attr "neon_type" "neon_int_1")]
+  "@
+   vbic\t%P0, %P1, %P2
+   #
+   #"
+  [(set_attr "neon_type" "neon_int_1,*,*")
+   (set_attr "length" "*,8,8")]
 )
 
 (define_insn "xor<mode>3"
@@ -1045,13 +1083,16 @@
 )
 
 (define_insn "xordi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w")
-		     (match_operand:DI 2 "s_register_operand" "w")]
-                    UNSPEC_VEOR))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?&r,?&r")
+        (xor:DI (match_operand:DI 1 "s_register_operand" "%w,0,r")
+	        (match_operand:DI 2 "s_register_operand" "w,r,r")))]
   "TARGET_NEON"
-  "veor\t%P0, %P1, %P2"
-  [(set_attr "neon_type" "neon_int_1")]
+  "@
+   veor\t%P0, %P1, %P2
+   #
+   #"
+  [(set_attr "neon_type" "neon_int_1,*,*")
+   (set_attr "length" "*,8,8")]
 )
 
 (define_insn "one_cmpl<mode>2"
@@ -1711,11 +1752,37 @@
 
 ; good for plain vadd, vaddq.
 
-(define_insn "neon_vadd<mode>"
+(define_expand "neon_vadd<mode>"
+  [(match_operand:VDQX 0 "s_register_operand" "=w")
+   (match_operand:VDQX 1 "s_register_operand" "w")
+   (match_operand:VDQX 2 "s_register_operand" "w")
+   (match_operand:SI 3 "immediate_operand" "i")]
+  "TARGET_NEON"
+{
+  if (!<Is_float_mode> || flag_unsafe_math_optimizations)
+    emit_insn (gen_add<mode>3 (operands[0], operands[1], operands[2]));
+  else
+    emit_insn (gen_neon_vadd<mode>_unspec (operands[0], operands[1],
+					   operands[2]));
+  DONE;
+})
+
+; Note that NEON operations don't support the full IEEE 754 standard: in
+; particular, denormal values are flushed to zero.  This means that GCC cannot
+; use those instructions for autovectorization, etc. unless
+; -funsafe-math-optimizations is in effect (in which case flush-to-zero
+; behaviour is permissible).  Intrinsic operations (provided by the arm_neon.h
+; header) must work in either case: if -funsafe-math-optimizations is given,
+; intrinsics expand to "canonical" RTL where possible, otherwise intrinsics
+; expand to unspecs (which may potentially limit the extent to which they might
+; be optimized by generic code).
+
+; Used for intrinsics when flag_unsafe_math_optimizations is false.
+
+(define_insn "neon_vadd<mode>_unspec"
   [(set (match_operand:VDQX 0 "s_register_operand" "=w")
         (unspec:VDQX [(match_operand:VDQX 1 "s_register_operand" "w")
-		      (match_operand:VDQX 2 "s_register_operand" "w")
-                      (match_operand:SI 3 "immediate_operand" "i")]
+		      (match_operand:VDQX 2 "s_register_operand" "w")]
                      UNSPEC_VADD))]
   "TARGET_NEON"
   "vadd.<V_if_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
@@ -1788,6 +1855,8 @@
   [(set_attr "neon_type" "neon_int_4")]
 )
 
+;; We cannot replace this unspec with mul<mode>3 because of the odd 
+;; polynomial multiplication case that can specified by operand 3.
 (define_insn "neon_vmul<mode>"
   [(set (match_operand:VDQW 0 "s_register_operand" "=w")
         (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "w")
@@ -1811,13 +1880,31 @@
                                     (const_string "neon_mul_qqq_8_16_32_ddd_32")))))]
 )
 
-(define_insn "neon_vmla<mode>"
-  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
-        (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")
-		      (match_operand:VDQW 2 "s_register_operand" "w")
-		      (match_operand:VDQW 3 "s_register_operand" "w")
-                     (match_operand:SI 4 "immediate_operand" "i")]
-                    UNSPEC_VMLA))]
+(define_expand "neon_vmla<mode>"
+  [(match_operand:VDQW 0 "s_register_operand" "=w")
+   (match_operand:VDQW 1 "s_register_operand" "0")
+   (match_operand:VDQW 2 "s_register_operand" "w")
+   (match_operand:VDQW 3 "s_register_operand" "w")
+   (match_operand:SI 4 "immediate_operand" "i")]
+  "TARGET_NEON"
+{
+  if (!<Is_float_mode> || flag_unsafe_math_optimizations)
+    emit_insn (gen_mul<mode>3add<mode>_neon (operands[0], operands[1],
+				             operands[2], operands[3]));
+  else
+    emit_insn (gen_neon_vmla<mode>_unspec (operands[0], operands[1],
+					   operands[2], operands[3]));
+  DONE;
+})
+
+; Used for intrinsics when flag_unsafe_math_optimizations is false.
+
+(define_insn "neon_vmla<mode>_unspec"
+  [(set (match_operand:VDQ 0 "s_register_operand" "=w")
+	(unspec:VDQ [(match_operand:VDQ 1 "s_register_operand" "0")
+		     (match_operand:VDQ 2 "s_register_operand" "w")
+		     (match_operand:VDQ 3 "s_register_operand" "w")]
+		    UNSPEC_VMLA))]
   "TARGET_NEON"
   "vmla.<V_if_elem>\t%<V_reg>0, %<V_reg>2, %<V_reg>3"
   [(set (attr "neon_type")
@@ -1850,13 +1937,31 @@
                    (const_string "neon_mla_ddd_32_qqd_16_ddd_32_scalar_qdd_64_32_long_scalar_qdd_64_32_long")))]
 )
 
-(define_insn "neon_vmls<mode>"
-  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
-        (unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "0")
-		      (match_operand:VDQW 2 "s_register_operand" "w")
-		      (match_operand:VDQW 3 "s_register_operand" "w")
-                     (match_operand:SI 4 "immediate_operand" "i")]
-                    UNSPEC_VMLS))]
+(define_expand "neon_vmls<mode>"
+  [(match_operand:VDQW 0 "s_register_operand" "=w")
+   (match_operand:VDQW 1 "s_register_operand" "0")
+   (match_operand:VDQW 2 "s_register_operand" "w")
+   (match_operand:VDQW 3 "s_register_operand" "w")
+   (match_operand:SI 4 "immediate_operand" "i")]
+  "TARGET_NEON"
+{
+  if (!<Is_float_mode> || flag_unsafe_math_optimizations)
+    emit_insn (gen_mul<mode>3neg<mode>add<mode>_neon (operands[0],
+		 operands[1], operands[2], operands[3]));
+  else
+    emit_insn (gen_neon_vmls<mode>_unspec (operands[0], operands[1],
+					   operands[2], operands[3]));
+  DONE;
+})
+
+; Used for intrinsics when flag_unsafe_math_optimizations is false.
+
+(define_insn "neon_vmls<mode>_unspec"
+  [(set (match_operand:VDQ 0 "s_register_operand" "=w")
+	(unspec:VDQ [(match_operand:VDQ 1 "s_register_operand" "0")
+		     (match_operand:VDQ 2 "s_register_operand" "w")
+		     (match_operand:VDQ 3 "s_register_operand" "w")]
+		    UNSPEC_VMLS))]
   "TARGET_NEON"
   "vmls.<V_if_elem>\t%<V_reg>0, %<V_reg>2, %<V_reg>3"
   [(set (attr "neon_type")
@@ -1966,11 +2071,27 @@
                    (const_string "neon_mul_qdd_64_32_long_qqd_16_ddd_32_scalar_64_32_long_scalar")))]
 )
 
-(define_insn "neon_vsub<mode>"
+(define_expand "neon_vsub<mode>"
+  [(match_operand:VDQX 0 "s_register_operand" "=w")
+   (match_operand:VDQX 1 "s_register_operand" "w")
+   (match_operand:VDQX 2 "s_register_operand" "w")
+   (match_operand:SI 3 "immediate_operand" "i")]
+  "TARGET_NEON"
+{
+  if (!<Is_float_mode> || flag_unsafe_math_optimizations)
+    emit_insn (gen_sub<mode>3 (operands[0], operands[1], operands[2]));
+  else
+    emit_insn (gen_neon_vsub<mode>_unspec (operands[0], operands[1],
+					   operands[2]));
+  DONE;
+})
+
+; Used for intrinsics when flag_unsafe_math_optimizations is false.
+
+(define_insn "neon_vsub<mode>_unspec"
   [(set (match_operand:VDQX 0 "s_register_operand" "=w")
         (unspec:VDQX [(match_operand:VDQX 1 "s_register_operand" "w")
-		      (match_operand:VDQX 2 "s_register_operand" "w")
-                      (match_operand:SI 3 "immediate_operand" "i")]
+		      (match_operand:VDQX 2 "s_register_operand" "w")]
                      UNSPEC_VSUB))]
   "TARGET_NEON"
   "vsub.<V_if_elem>\t%<V_reg>0, %<V_reg>1, %<V_reg>2"
@@ -2153,11 +2274,11 @@
 
 (define_insn "neon_vaba<mode>"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
-        (unspec:VDQIW [(match_operand:VDQIW 1 "s_register_operand" "0")
-		       (match_operand:VDQIW 2 "s_register_operand" "w")
-		       (match_operand:VDQIW 3 "s_register_operand" "w")
-                       (match_operand:SI 4 "immediate_operand" "i")]
-		      UNSPEC_VABA))]
+        (plus:VDQIW (match_operand:VDQIW 1 "s_register_operand" "0")
+                    (unspec:VDQIW [(match_operand:VDQIW 2 "s_register_operand" "w")
+		                   (match_operand:VDQIW 3 "s_register_operand" "w")
+                                   (match_operand:SI 4 "immediate_operand" "i")]
+		                  UNSPEC_VABD)))]
   "TARGET_NEON"
   "vaba.%T4%#<V_sz_elem>\t%<V_reg>0, %<V_reg>2, %<V_reg>3"
   [(set (attr "neon_type")
@@ -2167,11 +2288,11 @@
 
 (define_insn "neon_vabal<mode>"
   [(set (match_operand:<V_widen> 0 "s_register_operand" "=w")
-        (unspec:<V_widen> [(match_operand:<V_widen> 1 "s_register_operand" "0")
-		           (match_operand:VW 2 "s_register_operand" "w")
-		           (match_operand:VW 3 "s_register_operand" "w")
-                           (match_operand:SI 4 "immediate_operand" "i")]
-                          UNSPEC_VABAL))]
+        (plus:<V_widen> (match_operand:<V_widen> 1 "s_register_operand" "0")
+                        (unspec:<V_widen> [(match_operand:VW 2 "s_register_operand" "w")
+                                           (match_operand:VW 3 "s_register_operand" "w")
+                                           (match_operand:SI 4 "immediate_operand" "i")]
+                          UNSPEC_VABDL)))]
   "TARGET_NEON"
   "vabal.%T4%#<V_sz_elem>\t%q0, %P2, %P3"
   [(set_attr "neon_type" "neon_vaba")]
@@ -2302,22 +2423,15 @@
                     (const_string "neon_fp_vrecps_vrsqrts_qqq")))]
 )
 
-(define_insn "neon_vabs<mode>"
-  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
-	(unspec:VDQW [(match_operand:VDQW 1 "s_register_operand" "w")
-		      (match_operand:SI 2 "immediate_operand" "i")]
-                     UNSPEC_VABS))]
+(define_expand "neon_vabs<mode>"
+  [(match_operand:VDQW 0 "s_register_operand" "")
+   (match_operand:VDQW 1 "s_register_operand" "")
+   (match_operand:SI 2 "immediate_operand" "")]
   "TARGET_NEON"
-  "vabs.<V_s_elem>\t%<V_reg>0, %<V_reg>1"
-  [(set (attr "neon_type")
-     (if_then_else (ior (ne (symbol_ref "<Is_float_mode>") (const_int 0))
-                        (ne (symbol_ref "<Is_float_mode>") (const_int 0)))
-                   (if_then_else
-                      (ne (symbol_ref "<Is_d_reg>") (const_int 0))
-                      (const_string "neon_fp_vadd_ddd_vabs_dd")
-                      (const_string "neon_fp_vadd_qqq_vabs_qq"))
-                   (const_string "neon_vqneg_vqabs")))]
-)
+{
+  emit_insn (gen_abs<mode>2 (operands[0], operands[1]));
+  DONE;
+})
 
 (define_insn "neon_vqabs<mode>"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
@@ -2359,26 +2473,42 @@
   [(set_attr "neon_type" "neon_int_1")]
 )
 
-(define_insn "neon_vclz<mode>"
+(define_insn "clz<mode>2"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
-	(unspec:VDQIW [(match_operand:VDQIW 1 "s_register_operand" "w")
-		       (match_operand:SI 2 "immediate_operand" "i")]
-		      UNSPEC_VCLZ))]
+        (clz:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")))]
   "TARGET_NEON"
   "vclz.<V_if_elem>\t%<V_reg>0, %<V_reg>1"
   [(set_attr "neon_type" "neon_int_1")]
 )
 
-(define_insn "neon_vcnt<mode>"
+(define_expand "neon_vclz<mode>"
+  [(match_operand:VDQIW 0 "s_register_operand" "")
+   (match_operand:VDQIW 1 "s_register_operand" "")
+   (match_operand:SI 2 "immediate_operand" "")]
+  "TARGET_NEON"
+{
+  emit_insn (gen_clz<mode>2 (operands[0], operands[1]));
+  DONE;
+})
+
+(define_insn "popcount<mode>2"
   [(set (match_operand:VE 0 "s_register_operand" "=w")
-	(unspec:VE [(match_operand:VE 1 "s_register_operand" "w")
-                    (match_operand:SI 2 "immediate_operand" "i")]
-                   UNSPEC_VCNT))]
+        (popcount:VE (match_operand:VE 1 "s_register_operand" "w")))]
   "TARGET_NEON"
   "vcnt.<V_sz_elem>\t%<V_reg>0, %<V_reg>1"
   [(set_attr "neon_type" "neon_int_1")]
 )
 
+(define_expand "neon_vcnt<mode>"
+  [(match_operand:VE 0 "s_register_operand" "=w")
+   (match_operand:VE 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")]
+  "TARGET_NEON"
+{
+  emit_insn (gen_popcount<mode>2 (operands[0], operands[1]));
+  DONE;
+})
+
 (define_insn "neon_vrecpe<mode>"
   [(set (match_operand:V32 0 "s_register_operand" "=w")
 	(unspec:V32 [(match_operand:V32 1 "s_register_operand" "w")
@@ -2555,126 +2685,65 @@
 ; Operand 3 (info word) is ignored because it does nothing useful with 64-bit
 ; elements.
 
-(define_insn "neon_vget_lanedi"
-  [(set (match_operand:DI 0 "s_register_operand" "=r")
-       (unspec:DI [(match_operand:DI 1 "s_register_operand" "w")
-                   (match_operand:SI 2 "immediate_operand" "i")
-                   (match_operand:SI 3 "immediate_operand" "i")]
-                  UNSPEC_VGET_LANE))]
+(define_expand "neon_vget_lanedi"
+  [(match_operand:DI 0 "s_register_operand" "=r")
+   (match_operand:DI 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")
+   (match_operand:SI 3 "immediate_operand" "i")]
   "TARGET_NEON"
 {
   neon_lane_bounds (operands[2], 0, 1);
-  return "vmov%?\t%Q0, %R0, %P1  @ di";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
+  emit_move_insn (operands[0], operands[1]);
+  DONE;
+})
 
-(define_insn "neon_vget_lanev2di"
-  [(set (match_operand:DI 0 "s_register_operand" "=r")
-       (unspec:DI [(match_operand:V2DI 1 "s_register_operand" "w")
-                   (match_operand:SI 2 "immediate_operand" "i")
-                   (match_operand:SI 3 "immediate_operand" "i")]
-                  UNSPEC_VGET_LANE))]
+(define_expand "neon_vget_lanev2di"
+  [(match_operand:DI 0 "s_register_operand" "=r")
+   (match_operand:V2DI 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")
+   (match_operand:SI 3 "immediate_operand" "i")]
   "TARGET_NEON"
 {
-  rtx ops[2];
-  unsigned int regno = REGNO (operands[1]);
-  unsigned int elt = INTVAL (operands[2]);
-
   neon_lane_bounds (operands[2], 0, 2);
-
-  ops[0] = operands[0];
-  ops[1] = gen_rtx_REG (DImode, regno + 2 * elt);
-  output_asm_insn ("vmov%?\t%Q0, %R0, %P1  @ v2di", ops);
-
-  return "";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
-
-(define_insn "neon_vset_lane<mode>"
-  [(set (match_operand:VD 0 "s_register_operand" "=w")
-	(unspec:VD [(match_operand:<V_elem> 1 "s_register_operand" "r")
-		    (match_operand:VD 2 "s_register_operand" "0")
-                    (match_operand:SI 3 "immediate_operand" "i")]
-                   UNSPEC_VSET_LANE))]
+  emit_insn (gen_vec_extractv2di (operands[0], operands[1], operands[2]));
+  DONE;
+})
+
+(define_expand "neon_vset_lane<mode>"
+  [(match_operand:VDQ 0 "s_register_operand" "=w")
+   (match_operand:<V_elem> 1 "s_register_operand" "r")
+   (match_operand:VDQ 2 "s_register_operand" "0")
+   (match_operand:SI 3 "immediate_operand" "i")]
   "TARGET_NEON"
 {
+  unsigned int elt = INTVAL (operands[3]);
   neon_lane_bounds (operands[3], 0, GET_MODE_NUNITS (<MODE>mode));
-  return "vmov%?.<V_sz_elem>\t%P0[%c3], %1";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
+
+  if (BYTES_BIG_ENDIAN)
+    {
+      unsigned int reg_nelts
+	= 64 / GET_MODE_BITSIZE (GET_MODE_INNER (<MODE>mode));
+      elt ^= reg_nelts - 1;
+    }
+
+  emit_insn (gen_vec_set<mode>_internal (operands[0], operands[1],
+                                         GEN_INT (1 << elt), operands[2]));
+  DONE;
+})
 
 ; See neon_vget_lanedi comment for reasons operands 2 & 3 are ignored.
 
-(define_insn "neon_vset_lanedi"
-  [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "r")
-		    (match_operand:DI 2 "s_register_operand" "0")
-                    (match_operand:SI 3 "immediate_operand" "i")]
-                   UNSPEC_VSET_LANE))]
+(define_expand "neon_vset_lanedi"
+  [(match_operand:DI 0 "s_register_operand" "=w")
+   (match_operand:DI 1 "s_register_operand" "r")
+   (match_operand:DI 2 "s_register_operand" "0")
+   (match_operand:SI 3 "immediate_operand" "i")]
   "TARGET_NEON"
 {
   neon_lane_bounds (operands[3], 0, 1);
-  return "vmov%?\t%P0, %Q1, %R1  @ di";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
-
-(define_insn "neon_vset_lane<mode>"
-  [(set (match_operand:VQ 0 "s_register_operand" "=w")
-	(unspec:VQ [(match_operand:<V_elem> 1 "s_register_operand" "r")
-		    (match_operand:VQ 2 "s_register_operand" "0")
-                    (match_operand:SI 3 "immediate_operand" "i")]
-                   UNSPEC_VSET_LANE))]
-  "TARGET_NEON"
-{
-  rtx ops[4];
-  unsigned int regno = REGNO (operands[0]);
-  unsigned int halfelts = GET_MODE_NUNITS (<MODE>mode) / 2;
-  unsigned int elt = INTVAL (operands[3]);
-
-  neon_lane_bounds (operands[3], 0, halfelts * 2);
-
-  ops[0] = gen_rtx_REG (<V_HALF>mode, regno + 2 * (elt / halfelts));
-  ops[1] = operands[1];
-  ops[2] = GEN_INT (elt % halfelts);
-  output_asm_insn ("vmov%?.<V_sz_elem>\t%P0[%c2], %1", ops);
-
-  return "";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
-
-(define_insn "neon_vset_lanev2di"
-  [(set (match_operand:V2DI 0 "s_register_operand" "=w")
-	(unspec:V2DI [(match_operand:DI 1 "s_register_operand" "r")
-		      (match_operand:V2DI 2 "s_register_operand" "0")
-                      (match_operand:SI 3 "immediate_operand" "i")]
-                   UNSPEC_VSET_LANE))]
-  "TARGET_NEON"
-{
-  rtx ops[2];
-  unsigned int regno = REGNO (operands[0]);
-  unsigned int elt = INTVAL (operands[3]);
-
-  neon_lane_bounds (operands[3], 0, 2);
-
-  ops[0] = gen_rtx_REG (DImode, regno + 2 * elt);
-  ops[1] = operands[1];
-  output_asm_insn ("vmov%?\t%P0, %Q1, %R1  @ v2di", ops);
-
-  return "";
-}
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
+  emit_move_insn (operands[0], operands[1]);
+  DONE;
+})
 
 (define_expand "neon_vcreate<mode>"
   [(match_operand:VDX 0 "s_register_operand" "")
@@ -2688,8 +2757,7 @@
 
 (define_insn "neon_vdup_n<mode>"
   [(set (match_operand:VX 0 "s_register_operand" "=w")
-	(unspec:VX [(match_operand:<V_elem> 1 "s_register_operand" "r")]
-		   UNSPEC_VDUP_N))]
+        (vec_duplicate:VX (match_operand:<V_elem> 1 "s_register_operand" "r")))]
   "TARGET_NEON"
   "vdup%?.<V_sz_elem>\t%<V_reg>0, %1"
   ;; Assume this schedules like vmov.
@@ -2699,8 +2767,7 @@
 
 (define_insn "neon_vdup_n<mode>"
   [(set (match_operand:V32 0 "s_register_operand" "=w,w")
-	(unspec:V32 [(match_operand:<V_elem> 1 "s_register_operand" "r,t")]
-		    UNSPEC_VDUP_N))]
+        (vec_duplicate:V32 (match_operand:<V_elem> 1 "s_register_operand" "r,t")))]
   "TARGET_NEON"
   "@
   vdup%?.<V_sz_elem>\t%<V_reg>0, %1
@@ -2710,61 +2777,76 @@
    (set_attr "neon_type" "neon_bp_simple")]
 )
 
-(define_insn "neon_vdup_ndi"
-  [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "r")]
-                   UNSPEC_VDUP_N))]
+(define_expand "neon_vdup_ndi"
+  [(match_operand:DI 0 "s_register_operand" "=w")
+   (match_operand:DI 1 "s_register_operand" "r")]
   "TARGET_NEON"
-  "vmov%?\t%P0, %Q1, %R1"
-  [(set_attr "predicable" "yes")
-   (set_attr "neon_type" "neon_bp_simple")]
+{
+  emit_move_insn (operands[0], operands[1]);
+  DONE;
+}
 )
 
 (define_insn "neon_vdup_nv2di"
-  [(set (match_operand:V2DI 0 "s_register_operand" "=w")
-	(unspec:V2DI [(match_operand:DI 1 "s_register_operand" "r")]
-                     UNSPEC_VDUP_N))]
+  [(set (match_operand:V2DI 0 "s_register_operand" "=w,w")
+        (vec_duplicate:V2DI (match_operand:DI 1 "s_register_operand" "r,w")))]
   "TARGET_NEON"
-  "vmov%?\t%e0, %Q1, %R1\;vmov%?\t%f0, %Q1, %R1"
+  "@
+  vmov%?\t%e0, %Q1, %R1\;vmov%?\t%f0, %Q1, %R1
+  vmov%?\t%e0, %P1\;vmov%?\t%f0, %P1"
   [(set_attr "predicable" "yes")
    (set_attr "length" "8")
    (set_attr "neon_type" "neon_bp_simple")]
 )
 
-(define_insn "neon_vdup_lane<mode>"
-  [(set (match_operand:VD 0 "s_register_operand" "=w")
-	(unspec:VD [(match_operand:VD 1 "s_register_operand" "w")
-		    (match_operand:SI 2 "immediate_operand" "i")]
-                   UNSPEC_VDUP_LANE))]
+(define_insn "neon_vdup_lane<mode>_internal"
+  [(set (match_operand:VDQW 0 "s_register_operand" "=w")
+  	(vec_duplicate:VDQW 
+          (vec_select:<V_elem>
+            (match_operand:<V_double_vector_mode> 1 "s_register_operand" "w")
+            (parallel [(match_operand:SI 2 "immediate_operand" "i")]))))]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<MODE>mode));
-  return "vdup.<V_sz_elem>\t%P0, %P1[%c2]";
+  if (BYTES_BIG_ENDIAN)
+    {
+      int elt = INTVAL (operands[2]);
+      elt = GET_MODE_NUNITS (<V_double_vector_mode>mode) - 1 - elt;
+      operands[2] = GEN_INT (elt);
+    }
+  if (<Is_d_reg>)
+    return "vdup.<V_sz_elem>\t%P0, %P1[%c2]";
+  else
+    return "vdup.<V_sz_elem>\t%q0, %P1[%c2]";
 }
   ;; Assume this schedules like vmov.
   [(set_attr "neon_type" "neon_bp_simple")]
 )
 
-(define_insn "neon_vdup_lane<mode>"
-  [(set (match_operand:VQ 0 "s_register_operand" "=w")
-	(unspec:VQ [(match_operand:<V_HALF> 1 "s_register_operand" "w")
-		    (match_operand:SI 2 "immediate_operand" "i")]
-                   UNSPEC_VDUP_LANE))]
+(define_expand "neon_vdup_lane<mode>"
+  [(match_operand:VDQW 0 "s_register_operand" "=w")
+   (match_operand:<V_double_vector_mode> 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")]
   "TARGET_NEON"
 {
-  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<V_HALF>mode));
-  return "vdup.<V_sz_elem>\t%q0, %P1[%c2]";
-}
-  ;; Assume this schedules like vmov.
-  [(set_attr "neon_type" "neon_bp_simple")]
-)
+  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<V_double_vector_mode>mode));
+  if (BYTES_BIG_ENDIAN)
+    {
+      unsigned int elt = INTVAL (operands[2]);
+      unsigned int reg_nelts
+	= 64 / GET_MODE_BITSIZE (GET_MODE_INNER (<V_double_vector_mode>mode));
+      elt ^= reg_nelts - 1;
+      operands[2] = GEN_INT (elt);
+    }
+    emit_insn (gen_neon_vdup_lane<mode>_internal (operands[0], operands[1],
+                                                  operands[2]));
+    DONE;
+})
 
 ; Scalar index is ignored, since only zero is valid here.
 (define_expand "neon_vdup_lanedi"
-  [(set (match_operand:DI 0 "s_register_operand" "=w")
-	(unspec:DI [(match_operand:DI 1 "s_register_operand" "w")
-		    (match_operand:SI 2 "immediate_operand" "i")]
-                   UNSPEC_VDUP_LANE))]
+  [(match_operand:DI 0 "s_register_operand" "=w")
+   (match_operand:DI 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")]
   "TARGET_NEON"
 {
   neon_lane_bounds (operands[2], 0, 1);
@@ -2772,20 +2854,17 @@
   DONE;
 })
 
-; Likewise.
-(define_insn "neon_vdup_lanev2di"
-  [(set (match_operand:V2DI 0 "s_register_operand" "=w")
-	(unspec:V2DI [(match_operand:DI 1 "s_register_operand" "w")
-		      (match_operand:SI 2 "immediate_operand" "i")]
-                     UNSPEC_VDUP_LANE))]
+; Likewise for v2di, as the DImode second operand has only a single element.
+(define_expand "neon_vdup_lanev2di"
+  [(match_operand:V2DI 0 "s_register_operand" "=w")
+   (match_operand:DI 1 "s_register_operand" "w")
+   (match_operand:SI 2 "immediate_operand" "i")]
   "TARGET_NEON"
 {
   neon_lane_bounds (operands[2], 0, 1);
-  return "vmov\t%e0, %P1\;vmov\t%f0, %P1";
-}
-  [(set_attr "length" "8")
-   (set_attr "neon_type" "neon_bp_simple")]
-)
+  emit_insn (gen_neon_vdup_nv2di (operands[0], operands[1]));
+  DONE;
+})
 
 ;; In this insn, operand 1 should be low, and operand 2 the high part of the
 ;; dest vector.
@@ -2796,9 +2875,8 @@
 
 (define_insn "neon_vcombine<mode>"
   [(set (match_operand:<V_DOUBLE> 0 "s_register_operand" "=w")
-	(unspec:<V_DOUBLE> [(match_operand:VDX 1 "s_register_operand" "w")
-			    (match_operand:VDX 2 "s_register_operand" "w")]
-                           UNSPEC_VCOMBINE))]
+        (vec_concat:<V_DOUBLE> (match_operand:VDX 1 "s_register_operand" "w")
+			       (match_operand:VDX 2 "s_register_operand" "w")))]
   "TARGET_NEON"
 {
   int dest = REGNO (operands[0]);
@@ -2838,27 +2916,171 @@
    (set_attr "neon_type" "neon_bp_simple")]
 )
 
-(define_insn "neon_vget_high<mode>"
-  [(set (match_operand:<V_HALF> 0 "s_register_operand" "=w")
-	(unspec:<V_HALF> [(match_operand:VQX 1 "s_register_operand" "w")]
-			 UNSPEC_VGET_HIGH))]
-  "TARGET_NEON"
-{
-  int dest = REGNO (operands[0]);
-  int src = REGNO (operands[1]);
-
-  if (dest != src + 2)
-    return "vmov\t%P0, %f1";
-  else
-    return "";
-}
-  [(set_attr "neon_type" "neon_bp_simple")]
-)
-
-(define_insn "neon_vget_low<mode>"
-  [(set (match_operand:<V_HALF> 0 "s_register_operand" "=w")
-	(unspec:<V_HALF> [(match_operand:VQX 1 "s_register_operand" "w")]
-			 UNSPEC_VGET_LOW))]
+(define_insn "neon_vget_highv16qi"
+  [(set (match_operand:V8QI 0 "s_register_operand" "=w")
+	(vec_select:V8QI (match_operand:V16QI 1 "s_register_operand" "w")
+                         (parallel [(const_int 8) (const_int 9)
+			            (const_int 10) (const_int 11)
+				    (const_int 12) (const_int 13)
+				    (const_int 14) (const_int 15)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src + 2)
+    return "vmov\t%P0, %f1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_highv8hi"
+  [(set (match_operand:V4HI 0 "s_register_operand" "=w")
+	(vec_select:V4HI (match_operand:V8HI 1 "s_register_operand" "w")
+	                 (parallel [(const_int 4) (const_int 5)
+			            (const_int 6) (const_int 7)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src + 2)
+    return "vmov\t%P0, %f1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_highv4si"
+  [(set (match_operand:V2SI 0 "s_register_operand" "=w")
+	(vec_select:V2SI (match_operand:V4SI 1 "s_register_operand" "w")
+	                 (parallel [(const_int 2) (const_int 3)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src + 2)
+    return "vmov\t%P0, %f1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_highv4sf"
+  [(set (match_operand:V2SF 0 "s_register_operand" "=w")
+	(vec_select:V2SF (match_operand:V4SF 1 "s_register_operand" "w")
+	                 (parallel [(const_int 2) (const_int 3)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src + 2)
+    return "vmov\t%P0, %f1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_highv2di"
+  [(set (match_operand:DI 0 "s_register_operand" "=w")
+	(vec_select:DI (match_operand:V2DI 1 "s_register_operand" "w")
+	               (parallel [(const_int 1)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src + 2)
+    return "vmov\t%P0, %f1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_lowv16qi"
+  [(set (match_operand:V8QI 0 "s_register_operand" "=w")
+	(vec_select:V8QI (match_operand:V16QI 1 "s_register_operand" "w")
+                         (parallel [(const_int 0) (const_int 1)
+			            (const_int 2) (const_int 3)
+				    (const_int 4) (const_int 5)
+				    (const_int 6) (const_int 7)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src)
+    return "vmov\t%P0, %e1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_lowv8hi"
+  [(set (match_operand:V4HI 0 "s_register_operand" "=w")
+	(vec_select:V4HI (match_operand:V8HI 1 "s_register_operand" "w")
+	                 (parallel [(const_int 0) (const_int 1)
+			            (const_int 2) (const_int 3)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src)
+    return "vmov\t%P0, %e1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_lowv4si"
+  [(set (match_operand:V2SI 0 "s_register_operand" "=w")
+	(vec_select:V2SI (match_operand:V4SI 1 "s_register_operand" "w")
+	                 (parallel [(const_int 0) (const_int 1)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src)
+    return "vmov\t%P0, %e1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_lowv4sf"
+  [(set (match_operand:V2SF 0 "s_register_operand" "=w")
+	(vec_select:V2SF (match_operand:V4SF 1 "s_register_operand" "w")
+	                 (parallel [(const_int 0) (const_int 1)])))]
+  "TARGET_NEON"
+{
+  int dest = REGNO (operands[0]);
+  int src = REGNO (operands[1]);
+
+  if (dest != src)
+    return "vmov\t%P0, %e1";
+  else
+    return "";
+}
+  [(set_attr "neon_type" "neon_bp_simple")]
+)
+
+(define_insn "neon_vget_lowv2di"
+  [(set (match_operand:DI 0 "s_register_operand" "=w")
+	(vec_select:DI (match_operand:V2DI 1 "s_register_operand" "w")
+	               (parallel [(const_int 0)])))]
   "TARGET_NEON"
 {
   int dest = REGNO (operands[0]);

=== modified file 'gcc/config/arm/neon.ml'
--- old/gcc/config/arm/neon.ml	2010-01-19 14:21:14 +0000
+++ new/gcc/config/arm/neon.ml	2010-07-29 15:59:12 +0000
@@ -709,7 +709,8 @@
 let ops =
   [
     (* Addition.  *)
-    Vadd, [], All (3, Dreg), "vadd", sign_invar_2, F32 :: su_8_64;
+    Vadd, [], All (3, Dreg), "vadd", sign_invar_2, F32 :: su_8_32;
+    Vadd, [No_op], All (3, Dreg), "vadd", sign_invar_2, [S64; U64];
     Vadd, [], All (3, Qreg), "vaddQ", sign_invar_2, F32 :: su_8_64;
     Vadd, [], Long, "vaddl", elts_same_2, su_8_32;
     Vadd, [], Wide, "vaddw", elts_same_2, su_8_32;
@@ -758,7 +759,8 @@
     Vmls, [Saturating; Doubling], Long, "vqdmlsl", elts_same_io, [S16; S32];
 
     (* Subtraction.  *)
-    Vsub, [], All (3, Dreg), "vsub", sign_invar_2, F32 :: su_8_64;
+    Vsub, [], All (3, Dreg), "vsub", sign_invar_2, F32 :: su_8_32;
+    Vsub, [No_op], All (3, Dreg), "vsub", sign_invar_2,  [S64; U64];
     Vsub, [], All (3, Qreg), "vsubQ", sign_invar_2, F32 :: su_8_64;
     Vsub, [], Long, "vsubl", elts_same_2, su_8_32;
     Vsub, [], Wide, "vsubw", elts_same_2, su_8_32;
@@ -967,7 +969,8 @@
       Use_operands [| Corereg; Dreg; Immed |],
       "vget_lane", get_lane, pf_su_8_32;
     Vget_lane,
-      [InfoWord;
+      [No_op;
+       InfoWord;
        Disassembles_as [Use_operands [| Corereg; Corereg; Dreg |]];
        Instruction_name ["vmov"]; Const_valuator (fun _ -> 0)],
       Use_operands [| Corereg; Dreg; Immed |],
@@ -989,7 +992,8 @@
                 Instruction_name ["vmov"]],
       Use_operands [| Dreg; Corereg; Dreg; Immed |], "vset_lane",
       set_lane, pf_su_8_32;
-    Vset_lane, [Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]];
+    Vset_lane, [No_op;
+                Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]];
                 Instruction_name ["vmov"]; Const_valuator (fun _ -> 0)],
       Use_operands [| Dreg; Corereg; Dreg; Immed |], "vset_lane",
       set_lane_notype, [S64; U64];
@@ -1017,7 +1021,8 @@
       Use_operands [| Dreg; Corereg |], "vdup_n", bits_1,
       pf_su_8_32;
     Vdup_n,
-      [Instruction_name ["vmov"];
+      [No_op;
+       Instruction_name ["vmov"];
        Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]]],
       Use_operands [| Dreg; Corereg |], "vdup_n", notype_1,
       [S64; U64];
@@ -1028,7 +1033,8 @@
       Use_operands [| Qreg; Corereg |], "vdupQ_n", bits_1,
       pf_su_8_32;
     Vdup_n,
-      [Instruction_name ["vmov"];
+      [No_op;
+       Instruction_name ["vmov"];
        Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |];
                         Use_operands [| Dreg; Corereg; Corereg |]]],
       Use_operands [| Qreg; Corereg |], "vdupQ_n", notype_1,
@@ -1043,7 +1049,8 @@
       Use_operands [| Dreg; Corereg |],
       "vmov_n", bits_1, pf_su_8_32;
     Vmov_n,
-      [Builtin_name "vdup_n";
+      [No_op;
+       Builtin_name "vdup_n";
        Instruction_name ["vmov"];
        Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |]]],
       Use_operands [| Dreg; Corereg |],
@@ -1056,7 +1063,8 @@
       Use_operands [| Qreg; Corereg |],
       "vmovQ_n", bits_1, pf_su_8_32;
     Vmov_n,
-      [Builtin_name "vdupQ_n";
+      [No_op;
+       Builtin_name "vdupQ_n";
        Instruction_name ["vmov"];
        Disassembles_as [Use_operands [| Dreg; Corereg; Corereg |];
                         Use_operands [| Dreg; Corereg; Corereg |]]],
@@ -1613,23 +1621,28 @@
       store_3, [P16; F32; U16; U32; S16; S32];
 
     (* Logical operations. And.  *)
-    Vand, [], All (3, Dreg), "vand", notype_2, su_8_64;
+    Vand, [], All (3, Dreg), "vand", notype_2, su_8_32;
+    Vand, [No_op], All (3, Dreg), "vand", notype_2, [S64; U64];
     Vand, [], All (3, Qreg), "vandQ", notype_2, su_8_64;
 
     (* Or.  *)
-    Vorr, [], All (3, Dreg), "vorr", notype_2, su_8_64;
+    Vorr, [], All (3, Dreg), "vorr", notype_2, su_8_32;
+    Vorr, [No_op], All (3, Dreg), "vorr", notype_2, [S64; U64];
     Vorr, [], All (3, Qreg), "vorrQ", notype_2, su_8_64;
 
     (* Eor.  *)
-    Veor, [], All (3, Dreg), "veor", notype_2, su_8_64;
+    Veor, [], All (3, Dreg), "veor", notype_2, su_8_32;
+    Veor, [No_op], All (3, Dreg), "veor", notype_2, [S64; U64];
     Veor, [], All (3, Qreg), "veorQ", notype_2, su_8_64;
 
     (* Bic (And-not).  *)
-    Vbic, [], All (3, Dreg), "vbic", notype_2, su_8_64;
+    Vbic, [], All (3, Dreg), "vbic", notype_2, su_8_32;
+    Vbic, [No_op], All (3, Dreg), "vbic", notype_2, [S64; U64];
     Vbic, [], All (3, Qreg), "vbicQ", notype_2, su_8_64;
 
     (* Or-not.  *)
-    Vorn, [], All (3, Dreg), "vorn", notype_2, su_8_64;
+    Vorn, [], All (3, Dreg), "vorn", notype_2, su_8_32;
+    Vorn, [No_op], All (3, Dreg), "vorn", notype_2, [S64; U64];
     Vorn, [], All (3, Qreg), "vornQ", notype_2, su_8_64;
   ]
 

=== modified file 'gcc/config/arm/predicates.md'
--- old/gcc/config/arm/predicates.md	2009-07-15 09:12:22 +0000
+++ new/gcc/config/arm/predicates.md	2010-07-29 15:59:12 +0000
@@ -499,13 +499,15 @@
 (define_predicate "imm_for_neon_logic_operand"
   (match_code "const_vector")
 {
-  return neon_immediate_valid_for_logic (op, mode, 0, NULL, NULL);
+  return (TARGET_NEON
+          && neon_immediate_valid_for_logic (op, mode, 0, NULL, NULL));
 })
 
 (define_predicate "imm_for_neon_inv_logic_operand"
   (match_code "const_vector")
 {
-  return neon_immediate_valid_for_logic (op, mode, 1, NULL, NULL);
+  return (TARGET_NEON
+          && neon_immediate_valid_for_logic (op, mode, 1, NULL, NULL));
 })
 
 (define_predicate "neon_logic_op2"

=== modified file 'gcc/doc/arm-neon-intrinsics.texi'
--- old/gcc/doc/arm-neon-intrinsics.texi	2009-11-18 17:06:46 +0000
+++ new/gcc/doc/arm-neon-intrinsics.texi	2010-07-29 15:59:12 +0000
@@ -43,20 +43,18 @@
 
 
 @itemize @bullet
+@item float32x2_t vadd_f32 (float32x2_t, float32x2_t)
+@*@emph{Form of expected instruction(s):} @code{vadd.f32 @var{d0}, @var{d0}, @var{d0}}
+@end itemize
+
+
+@itemize @bullet
 @item uint64x1_t vadd_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vadd.i64 @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vadd_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vadd.i64 @var{d0}, @var{d0}, @var{d0}}
-@end itemize
-
-
-@itemize @bullet
-@item float32x2_t vadd_f32 (float32x2_t, float32x2_t)
-@*@emph{Form of expected instruction(s):} @code{vadd.f32 @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
@@ -1013,20 +1011,18 @@
 
 
 @itemize @bullet
+@item float32x2_t vsub_f32 (float32x2_t, float32x2_t)
+@*@emph{Form of expected instruction(s):} @code{vsub.f32 @var{d0}, @var{d0}, @var{d0}}
+@end itemize
+
+
+@itemize @bullet
 @item uint64x1_t vsub_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vsub.i64 @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vsub_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vsub.i64 @var{d0}, @var{d0}, @var{d0}}
-@end itemize
-
-
-@itemize @bullet
-@item float32x2_t vsub_f32 (float32x2_t, float32x2_t)
-@*@emph{Form of expected instruction(s):} @code{vsub.f32 @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
@@ -4750,13 +4746,11 @@
 
 @itemize @bullet
 @item uint64_t vget_lane_u64 (uint64x1_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{r0}, @var{r0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64_t vget_lane_s64 (int64x1_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{r0}, @var{r0}, @var{d0}}
 @end itemize
 
 
@@ -4886,13 +4880,11 @@
 
 @itemize @bullet
 @item uint64x1_t vset_lane_u64 (uint64_t, uint64x1_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vset_lane_s64 (int64_t, int64x1_t, const int)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
@@ -5081,13 +5073,11 @@
 
 @itemize @bullet
 @item uint64x1_t vdup_n_u64 (uint64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vdup_n_s64 (int64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
@@ -5147,13 +5137,11 @@
 
 @itemize @bullet
 @item uint64x2_t vdupq_n_u64 (uint64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x2_t vdupq_n_s64 (int64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
@@ -5213,13 +5201,11 @@
 
 @itemize @bullet
 @item uint64x1_t vmov_n_u64 (uint64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vmov_n_s64 (int64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
@@ -5279,13 +5265,11 @@
 
 @itemize @bullet
 @item uint64x2_t vmovq_n_u64 (uint64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x2_t vmovq_n_s64 (int64_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{r0}, @var{r0}}
 @end itemize
 
 
@@ -5572,18 +5556,6 @@
 
 
 @itemize @bullet
-@item uint64x1_t vget_low_u64 (uint64x2_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{d0}}
-@end itemize
-
-
-@itemize @bullet
-@item int64x1_t vget_low_s64 (int64x2_t)
-@*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{d0}}
-@end itemize
-
-
-@itemize @bullet
 @item float32x2_t vget_low_f32 (float32x4_t)
 @*@emph{Form of expected instruction(s):} @code{vmov @var{d0}, @var{d0}}
 @end itemize
@@ -5601,6 +5573,16 @@
 @end itemize
 
 
+@itemize @bullet
+@item uint64x1_t vget_low_u64 (uint64x2_t)
+@end itemize
+
+
+@itemize @bullet
+@item int64x1_t vget_low_s64 (int64x2_t)
+@end itemize
+
+
 
 
 @subsubsection Conversions
@@ -9727,13 +9709,11 @@
 
 @itemize @bullet
 @item uint64x1_t vand_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vand @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vand_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vand @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
@@ -9827,13 +9807,11 @@
 
 @itemize @bullet
 @item uint64x1_t vorr_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vorr @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vorr_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vorr @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
@@ -9927,13 +9905,11 @@
 
 @itemize @bullet
 @item uint64x1_t veor_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{veor @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t veor_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{veor @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
@@ -10027,13 +10003,11 @@
 
 @itemize @bullet
 @item uint64x1_t vbic_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vbic @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vbic_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vbic @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
@@ -10127,13 +10101,11 @@
 
 @itemize @bullet
 @item uint64x1_t vorn_u64 (uint64x1_t, uint64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vorn @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 
 @itemize @bullet
 @item int64x1_t vorn_s64 (int64x1_t, int64x1_t)
-@*@emph{Form of expected instruction(s):} @code{vorn @var{d0}, @var{d0}, @var{d0}}
 @end itemize
 
 

=== added file 'gcc/testsuite/gcc.target/arm/neon-vadds64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vadds64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vadds64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vadd_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)0x00000000deadbeefLL;
+
+  out_int64x1_t = vadd_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdeadbeefdeadbeefLL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vaddu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vaddu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vaddu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vadd_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)0x00000000deadbeefLL;
+
+  out_uint64x1_t = vadd_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdeadbeefdeadbeefLL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vands64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vands64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vands64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vand_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)0xdead00000000beefLL;
+
+  out_int64x1_t = vand_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdead000000000000LL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vandu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vandu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vandu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vand_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)0xdead00000000beefLL;
+
+  out_uint64x1_t = vand_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdead000000000000LL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vbics64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vbics64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vbics64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vbic_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)(~0xdead00000000beefLL);
+
+  out_int64x1_t = vbic_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdead000000000000LL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vbicu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vbicu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vbicu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vbic_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)(~0xdead00000000beefLL);
+
+  out_uint64x1_t = vbic_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdead000000000000LL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vdupQ_lanes64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vdupQ_lanes64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vdupQ_lanes64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,22 @@
+/* Test the `vdupq_lanes64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x2_t out_int64x2_t = {0, 0};
+  int64_t arg0_int64_t = (int64_t) 0xdeadbeef;
+
+  out_int64x2_t = vdupq_lane_s64 ((int64x1_t)arg0_int64_t, 0);
+  if (vgetq_lane_s64 (out_int64x2_t, 0) != arg0_int64_t)
+    abort();
+  if (vgetq_lane_s64 (out_int64x2_t, 1) != arg0_int64_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vdupQ_laneu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vdupQ_laneu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vdupQ_laneu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,22 @@
+/* Test the `vdupq_laneu64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x2_t out_uint64x2_t = {0, 0};
+  uint64_t arg0_uint64_t = (uint64_t) 0xdeadbeef;
+
+  out_uint64x2_t = vdupq_lane_u64 ((uint64x1_t)arg0_uint64_t, 0);
+  if (vgetq_lane_u64 (out_uint64x2_t, 0) != arg0_uint64_t)
+    abort();
+  if (vgetq_lane_u64 (out_uint64x2_t, 1) != arg0_uint64_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vdupQ_ns64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vdupQ_ns64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vdupQ_ns64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,22 @@
+/* Test the `vdupq_ns64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x2_t out_int64x2_t = {0, 0};
+  int64_t arg0_int64_t = (int64_t) 0xdeadbeef;
+
+  out_int64x2_t = vdupq_n_s64 (arg0_int64_t);
+  if (vgetq_lane_s64 (out_int64x2_t, 0) != arg0_int64_t)
+    abort();
+  if (vgetq_lane_s64 (out_int64x2_t, 1) != arg0_int64_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vdupQ_nu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vdupQ_nu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vdupQ_nu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,22 @@
+/* Test the `vdupq_nu64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x2_t out_uint64x2_t = {0, 0};
+  uint64_t arg0_uint64_t = (uint64_t) 0xdeadbeef;
+
+  out_uint64x2_t = vdupq_n_u64 (arg0_uint64_t);
+  if (vgetq_lane_u64 (out_uint64x2_t, 0) != arg0_uint64_t)
+    abort();
+  if (vgetq_lane_u64 (out_uint64x2_t, 1) != arg0_uint64_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vdup_ns64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vdup_ns64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vdup_ns64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,20 @@
+/* Test the `vdup_ns64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64_t arg0_int64_t = (int64_t) 0xdeadbeef;
+
+  out_int64x1_t = vdup_n_s64 (arg0_int64_t);
+  if ((int64_t)out_int64x1_t != arg0_int64_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vdup_nu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vdup_nu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vdup_nu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,20 @@
+/* Test the `vdup_nu64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64_t arg0_uint64_t = (uint64_t) 0xdeadbeef;
+
+  out_uint64x1_t = vdup_n_u64 (arg0_uint64_t);
+  if ((uint64_t)out_uint64x1_t != arg0_uint64_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-veors64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-veors64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-veors64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `veor_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)0xdead00000000beefLL;
+
+  out_int64x1_t = veor_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0x0000beef0000beefLL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-veoru64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-veoru64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-veoru64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `veor_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)0xdead00000000beefLL;
+
+  out_uint64x1_t = veor_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0x0000beef0000beefLL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vget_lanes64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vget_lanes64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vget_lanes64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,20 @@
+/* Test the `vget_lane_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64_t out_int64_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t) 0xdeadbeefbadf00dLL;
+
+  out_int64_t = vget_lane_s64 (arg0_int64x1_t, 0);
+  if (out_int64_t != (int64_t)arg0_int64x1_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vget_laneu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vget_laneu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vget_laneu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,20 @@
+/* Test the `vget_lane_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64_t out_uint64_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t) 0xdeadbeefbadf00dLL;
+
+  out_uint64_t = vget_lane_u64 (arg0_uint64x1_t, 0);
+  if (out_uint64_t != (uint64_t)arg0_uint64x1_t)
+    abort();
+  return 0;
+}

=== modified file 'gcc/testsuite/gcc.target/arm/neon-vmla-1.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vmla-1.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vmla-1.c	2010-07-29 15:59:12 +0000
@@ -1,5 +1,5 @@
 /* { dg-require-effective-target arm_neon_hw } */
-/* { dg-options "-O2 -ftree-vectorize" } */
+/* { dg-options "-O2 -ftree-vectorize -ffast-math" } */
 /* { dg-add-options arm_neon } */
 /* { dg-final { scan-assembler "vmla\\.f32" } } */
 

=== modified file 'gcc/testsuite/gcc.target/arm/neon-vmls-1.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vmls-1.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vmls-1.c	2010-07-29 15:59:12 +0000
@@ -1,5 +1,5 @@
 /* { dg-require-effective-target arm_neon_hw } */
-/* { dg-options "-O2 -ftree-vectorize" } */
+/* { dg-options "-O2 -ftree-vectorize -ffast-math" } */
 /* { dg-add-options arm_neon } */
 /* { dg-final { scan-assembler "vmls\\.f32" } } */
 

=== added file 'gcc/testsuite/gcc.target/arm/neon-vmovQ_ns64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vmovQ_ns64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vmovQ_ns64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,22 @@
+/* Test the `vmovq_ns64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x2_t out_int64x2_t = {0, 0};
+  int64_t arg0_int64_t = (int64_t) 0xdeadbeef;
+
+  out_int64x2_t = vmovq_n_s64 (arg0_int64_t);
+  if (vgetq_lane_s64 (out_int64x2_t, 0) != arg0_int64_t)
+    abort();
+  if (vgetq_lane_s64 (out_int64x2_t, 1) != arg0_int64_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vmovQ_nu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vmovQ_nu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vmovQ_nu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,23 @@
+/* Test the `vmovq_nu64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x2_t out_uint64x2_t = {0, 0};
+  uint64_t arg0_uint64_t = (uint64_t) 0xdeadbeef;
+
+  out_uint64x2_t = vmovq_n_u64 (arg0_uint64_t);
+  if (vgetq_lane_u64 (out_uint64x2_t, 0) != arg0_uint64_t)
+    abort();
+  if (vgetq_lane_u64 (out_uint64x2_t, 1) != arg0_uint64_t)
+    abort();
+  return 0;
+}
+

=== added file 'gcc/testsuite/gcc.target/arm/neon-vmov_ns64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vmov_ns64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vmov_ns64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,20 @@
+/* Test the `vmov_ns64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64_t arg0_int64_t = (int64_t) 0xdeadbeef;
+
+  out_int64x1_t = vmov_n_s64 (arg0_int64_t);
+  if ((int64_t)out_int64x1_t != arg0_int64_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vmov_nu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vmov_nu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vmov_nu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,20 @@
+/* Test the `vmov_nu64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64_t arg0_uint64_t = (uint64_t) 0xdeadbeef;
+
+  out_uint64x1_t = vmov_n_u64 (arg0_uint64_t);
+  if ((uint64_t)out_uint64x1_t != arg0_uint64_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vorns64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vorns64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vorns64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vorn_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)(~0xdead00000000beefLL);
+
+  out_int64x1_t = vorn_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdeadbeef0000beefLL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vornu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vornu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vornu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vorn_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)(~0xdead00000000beefLL);
+
+  out_uint64x1_t = vorn_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdeadbeef0000beefLL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vorrs64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vorrs64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vorrs64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vorr_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeef00000000LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)0xdead00000000beefLL;
+
+  out_int64x1_t = vorr_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdeadbeef0000beefLL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vorru64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vorru64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vorru64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vorr_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeef00000000LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)0xdead00000000beefLL;
+
+  out_uint64x1_t = vorr_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdeadbeef0000beefLL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vset_lanes64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vset_lanes64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vset_lanes64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vset_lane_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64_t arg0_int64_t = 0xf00f00f00LL;
+  int64x1_t arg1_int64x1_t = (int64x1_t) 0xdeadbeefbadf00dLL;
+
+  out_int64x1_t = vset_lane_s64 (arg0_int64_t, arg1_int64x1_t, 0);
+  if ((int64_t)out_int64x1_t != arg0_int64_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vset_laneu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vset_laneu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vset_laneu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vset_lane_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64_t arg0_uint64_t = 0xf00f00f00LL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t) 0xdeadbeefbadf00dLL;
+
+  out_uint64x1_t = vset_lane_u64 (arg0_uint64_t, arg1_uint64x1_t, 0);
+  if ((uint64_t)out_uint64x1_t != arg0_uint64_t)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vsubs64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vsubs64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vsubs64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vsub_s64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  int64x1_t out_int64x1_t = 0;
+  int64x1_t arg0_int64x1_t = (int64x1_t)0xdeadbeefdeadbeefLL;
+  int64x1_t arg1_int64x1_t = (int64x1_t)0x0000beefdead0000LL;
+
+  out_int64x1_t = vsub_s64 (arg0_int64x1_t, arg1_int64x1_t);
+  if (out_int64x1_t != (int64x1_t)0xdead00000000beefLL)
+    abort();
+  return 0;
+}

=== added file 'gcc/testsuite/gcc.target/arm/neon-vsubu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon-vsubu64.c	1970-01-01 00:00:00 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon-vsubu64.c	2010-07-29 15:59:12 +0000
@@ -0,0 +1,21 @@
+/* Test the `vsub_u64' ARM Neon intrinsic.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O0" } */
+/* { dg-add-options arm_neon } */
+
+#include "arm_neon.h"
+#include <stdlib.h>
+
+int main (void)
+{
+  uint64x1_t out_uint64x1_t = 0;
+  uint64x1_t arg0_uint64x1_t = (uint64x1_t)0xdeadbeefdeadbeefLL;
+  uint64x1_t arg1_uint64x1_t = (uint64x1_t)0x0000beefdead0000LL;
+
+  out_uint64x1_t = vsub_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
+  if (out_uint64x1_t != (uint64x1_t)0xdead00000000beefLL)
+    abort();
+  return 0;
+}

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vadds64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vadds64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vadds64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_int64x1_t = vadd_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vaddu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vaddu64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vaddu64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_uint64x1_t = vadd_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vands64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vands64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vands64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_int64x1_t = vand_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vandu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vandu64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vandu64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_uint64x1_t = vand_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vbics64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vbics64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vbics64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_int64x1_t = vbic_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vbicu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vbicu64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vbicu64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_uint64x1_t = vbic_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns64.c	2010-07-29 15:59:12 +0000
@@ -16,6 +16,4 @@
   out_int64x2_t = vdupq_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu64.c	2010-07-29 15:59:12 +0000
@@ -16,6 +16,4 @@
   out_uint64x2_t = vdupq_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vdup_ns64.c	2010-07-29 15:59:12 +0000
@@ -16,5 +16,4 @@
   out_int64x1_t = vdup_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vdup_nu64.c	2010-07-29 15:59:12 +0000
@@ -16,5 +16,4 @@
   out_uint64x1_t = vdup_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/veors64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/veors64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/veors64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_int64x1_t = veor_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/veoru64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/veoru64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/veoru64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_uint64x1_t = veor_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vget_lanes64.c	2010-07-29 15:59:12 +0000
@@ -16,5 +16,4 @@
   out_int64_t = vget_lane_s64 (arg0_int64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[rR\]\[0-9\]+, \[rR\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vget_laneu64.c	2010-07-29 15:59:12 +0000
@@ -16,5 +16,4 @@
   out_uint64_t = vget_lane_u64 (arg0_uint64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[rR\]\[0-9\]+, \[rR\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns64.c	2010-07-29 15:59:12 +0000
@@ -16,6 +16,4 @@
   out_int64x2_t = vmovq_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu64.c	2010-07-29 15:59:12 +0000
@@ -16,6 +16,4 @@
   out_uint64x2_t = vmovq_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vmov_ns64.c	2010-07-29 15:59:12 +0000
@@ -16,5 +16,4 @@
   out_int64x1_t = vmov_n_s64 (arg0_int64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vmov_nu64.c	2010-07-29 15:59:12 +0000
@@ -16,5 +16,4 @@
   out_uint64x1_t = vmov_n_u64 (arg0_uint64_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vorns64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vorns64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vorns64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_int64x1_t = vorn_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vornu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vornu64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vornu64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_uint64x1_t = vorn_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vorrs64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vorrs64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vorrs64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_int64x1_t = vorr_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vorru64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vorru64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vorru64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_uint64x1_t = vorr_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vset_lanes64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_int64x1_t = vset_lane_s64 (arg0_int64_t, arg1_int64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vset_laneu64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_uint64x1_t = vset_lane_u64 (arg0_uint64_t, arg1_uint64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vsubs64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vsubs64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vsubs64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_int64x1_t = vsub_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

=== modified file 'gcc/testsuite/gcc.target/arm/neon/vsubu64.c'
--- old/gcc/testsuite/gcc.target/arm/neon/vsubu64.c	2010-07-29 15:38:15 +0000
+++ new/gcc/testsuite/gcc.target/arm/neon/vsubu64.c	2010-07-29 15:59:12 +0000
@@ -17,5 +17,4 @@
   out_uint64x1_t = vsub_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */

